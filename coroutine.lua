---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by chuckchen.
---

--- Lua 协同程序(coroutine)与线程比较类似：拥有独立的堆栈，独立的局部变量，独立的指令指针，同时又与其它协同程序共享全局变量和其它大部分东西。
--- 线程和协同程序区别
--- 线程与协同程序的主要区别在于，一个具有多个线程的程序可以同时运行几个线程，而协同程序却需要彼此协作的运行。
--- 在任一指定时刻只有一个协同程序在运行，并且这个正在运行的协同程序只有在明确的被要求挂起的时候才会被挂起。
--- 协同程序有点类似同步的多线程，在等待同一个线程锁的几个线程有点类似协同。

--coroutine.create() 创建 coroutine，返回 coroutine， 参数是一个函数，当和 resume 配合使用的时候就唤醒函数调用
co = coroutine.create(
        function(i)
            print(i);
        end
)

--coroutine.resume() 重启 coroutine，和 create
--配合使用 对于正常结束， coroutine.resume 将返回 true， 并接上协程主函数的返回值。 当错误发生时， coroutine.resume 将返回 false 与错误消息。
coroutine.resume(co, 1)

--coroutine.status() 查看 coroutine 的状态 coroutine 的状态有三种：dead，suspended，running
print(coroutine.status(co))


--coroutine.wrap() 创建 coroutine，返回一个函数，一旦你调用这个函数，就进入 coroutine，和 create 功能重复
co = coroutine.wrap(
        function(i)
            print(i);
        end
)
co(1)


print("----------")

--coroutine.running() 返回正在跑的 coroutine，一个 coroutine 就是一个线程，当使用running的时候，就是返回一个 corouting 的线程号
--coroutine.yield() 挂起 coroutine，将 coroutine 设置为挂起状态，这个和 resume 配合使用能有很多有用的效果
co2 = coroutine.create(
        function()
            for i = 1, 10 do
                print(i)
                if i == 3 then
                    print(coroutine.status(co2))
                    print(coroutine.running())
                end
                coroutine.yield() --co2被挂起 等待被再次resume
            end
        end
)
coroutine.resume(co2)
coroutine.resume(co2)
coroutine.resume(co2)

print(coroutine.status(co2))
print(coroutine.running())



--resume和yield的配合强大之处在于，resume处于主程中，它将外部状态（数据）传入到协同程序内部；而yield则将内部的状态（数据）返回到主程中。
---print("----------")
function foo(a)
    print("foo函数输出", a)
    return coroutine.yield(2*a) --yield的参数的计算值值即为当前resume的返回值 等第二个resume唤醒它时 resume的参数即为foo的返回值
end

co = coroutine.create(
        function(a, b)
            print("第一次协同程序执行输出", a, b)
            local r = foo(a + 1)

            print("第二次协同程序执行输出", r)
            local r, s = coroutine.yield(a+b, a-b)

            print("第三次协同程序执行输出", r, s)
            return b, "结束协同程序"
        end
)

print("main", coroutine.resume(co, 1, 10)) --true, 4
print("------------")
print("main", coroutine.resume(co, "a")) -- true 10, -9
print("------------")
print("main", coroutine.resume(co, "x", "y")) --true 10, "结束协同程序"
print("------------")
print("main", coroutine.resume(co, "x", "y")) --false cannot resume dead coroutine
print("------------")


-- resume 与 yield 实现生产者与消费者问题
local newProducer

--生产
function send(x)
    coroutine.yield(x)
end

function producer()
    local i = 0
    while true do
        i = i+1
        send(i)
    end
end

--消费
function receive()
    local status, value = coroutine.resume(newProducer)
    return value
end

function consumer()
    while true do
        local value = receive()
        print(value)
    end
end

--启动程序
newProducer = coroutine.create(producer)
consumer()